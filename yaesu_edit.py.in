#!/usr/bin/env python
#
#    yaesu_edit - Edit yaesu clone files
#    Copyright (C) 2009  Corey Minyard
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin Street, Fifth Floor,
#      Boston, MA  02110-1301  USA

import sys
import traceback
import Tix

radiodir = "@YAESU_CONFIGDIR@"

decimal_digits = "0123456789"

# These are internal Yaesu string values for some radios, and a clean set
# of characters to allow in general strings.
ys_chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ !\"\\$#%'()*+,-;/|:<=>?@[&]^_"

class ParseException(Exception):
    def __init__(self, filename, lineno, err):
        self.filename = filename
        self.lineno = lineno.get()
        self.err = err
        pass
    
    def __str__(self):
        return self.filename + "(" + str(self.lineno) + "): " + self.err
    
    pass

class DataException(Exception):
    def __init__(self, err):
        self.err = err
        pass

    def __str__(self):
        return self.err
    
    pass

class RadioInfo:
    def __init__(self, name):
        self.name = name;
        self.headercmp = []
        return

    pass

radios = []

def find_radio(data):
    for r in radios:
        if (len(data) < len(r.headercmp)):
            continue
        found = True
        i = 0
        for b in r.headercmp:
            if (b != data[i]):
                found = False
                break
            i += 1
            pass
        if (found):
            return r.name
        pass
    return None

# Throws IOError and ParseException
def read_radios():
    filename = radiodir + "/radios"
    f = open(filename, "r");
    try:
        lineno = 0
        in_radio = False
        l = ""
        while True:
            l += f.readline()
            if (not l):
                break;
            lineno += 1
            if l[len(l) - 1] == '\\':
               continue 
            if l[0] == '#':
                l = ""
                continue
            v = l.split();
            l = ""
            if (not v):
                continue
            if (v[0] == "radio"):
                if (in_radio):
                    raise ParseException(filename, lineno,
                                         "Got radio start inside a radio")
                if (len(v) < 2):
                    raise ParseException(filename, lineno,
                                         "No radio specified")
                curr_radio = RadioInfo(v[1])
                in_radio = True
                continue
            if (v[0] == "endradio"):
                if (not in_radio):
                    raise ParseException(filename, lineno,
                                         "Got radio end outside a radio")
                if (len(curr_radio.headercmp) == 0):
                    raise ParseException(filename, lineno,
                                         "No headercmp for radio")
                radios.append(curr_radio)
                in_radio = False
                continue
            if (v[0] == "headercmp"):
                if (not in_radio):
                    raise ParseException(filename, lineno,
                                         "Got headercmp outside a radio")
                try:
                    i = 0
                    found = True
                    for ns in v[1:]:
                        n = int(ns, 16)
                        if (n > 255):
                            raise TypeError("Number too large")
                        curr_radio.headercmp.append(n)
                        i += 1
                        pass
                    pass
                except TypeError, e:
                    raise ParseException(filename, lineno,
                                         "invalid hexadecimal 8-bit number")
                except ValueError, e:
                    raise ParseException(filename, lineno,
                                         "invalid hexadecimal 8-bit number")
                pass
            pass
        pass
    except:
        exceptionType, exceptionValue, exceptionTraceback = sys.exc_info()
        f.close()
        raise exceptionType, exceptionValue, exceptionTraceback
    return

class Address:
    def __init__(self, c, s):
        l = len(s)
        if (l == 0):
            raise ParseException(c.filename, c.lineno,
                                 "Empty location");
        if (s[0] != '('):
            raise ParseException(c.filename, c.lineno,
                                 "Address doesn't start with (");
        if (s[l-1] != ')'):
            raise ParseException(c.filename, c.lineno,
                                 "Address doesn't end with )");
        self.entries = []
        self.revbits = False # Bits are numbered from 0 by default
        i = 1
        l -= 1
        pos = 0
        start = 1
        v = [0, 0, 0, 0]
        self.entries.append(v)
        while (i < l):
            if (s[i] == ','):
                v[pos] = c.toNum(s[start:i])
                start = i + 1
                pos += 1
                if (pos > 3):
                    raise ParseException(c.filename, c.lineno,
                                         "Address has too many values"
                                         + " in a field");
                pass
            elif (s[i] == ':'):
                if (pos < 2 or pos > 3):
                    raise ParseException(c.filename, c.lineno,
                                         "Address has too few values"
                                         + " in a field");
                v[pos] = c.toNum(s[start:i])
                start = i + 1
                pos = 0
                v = [0, 0, 0, 0]
                self.entries.append(v)
                pass
            i += 1
            pass
        if (pos < 2 or pos > 3):
            raise ParseException(c.filename, c.lineno,
                                 "Address has too few values"
                                 + " in a field");
        if ((pos == 3) and (s[start] == 'r')):
            # Number bits starting with the high order.
            start += 1
            self.revbits = True
            pass
        v[pos] = c.toNum(s[start:i])
    pass


class RadioFileData:
    # Throws IOError
    def __init__(self, filename):
        self.filename = filename
        f = open(filename, "rb")
        strdata = f.read();
        f.close()
        self.data = []
        for c in strdata:
            self.data.append(ord(c))
        self.changed = False
        pass

    def write(self, filename=None):
        if (filename == None):
            filename = self.filename
        else:
            self.filename = filename
            pass
        outs = []
        for c in self.data:
            outs.append(chr(c))
            pass
        s = "".join(outs)
        try:
            f = open(filename, "wb")
            f.write(s)
        finally:
            f.close()
            pass
        self.changed = False
        pass

    # The get and set routine throw IndexError if out of range.
    
    def get_bits_le(self, addr, num):
        v = 0
        for a in addr.entries:
            byte_off = a[0]
            bit_off = a[1] + a[3] * num
            byte_off += bit_off / 8
            bit_off %= 8
            numbits = a[2]
            v <<= numbits
            
            x = self.data[byte_off] >> bit_off
            bits = 8 - bit_off
            shift = bit_off
            while (bits < numbits):
                byte_off += 1
                x |= self.data[byte_off] << shift
                shift += 8
                bits += 8
                pass
            v |= x & ~(0xffffffff << numbits)
            pass
        return v

    def set_bits_le(self, vt, addr, num):
        self.changed = True
        bitsleft = 0
        for a in addr.entries:
            bitsleft += a[2]
            pass
        for a in addr.entries:
            byte_off = a[0]
            bit_off = a[1] + a[3] * num
            byte_off += bit_off / 8
            bit_off %= 8
            numbits = a[2]
            bitsleft -= numbits

            v = vt >> bitsleft
            v = v & ~(0xffffffff << numbits)
        
            x = self.data[byte_off]
            if ((bit_off + numbits) <= 8):
                # Special case, all in one byte
                mask = (0xff >> (8 - numbits)) << bit_off
                x &= ~ mask
                x |= (v << bit_off) & mask
                self.data[byte_off] = x
                continue
            mask = 0xff << bit_off
            x &= ~mask
            self.data[byte_off] = x | ((v << bit_off) & mask)
            byte_off += 1
            v >>= bit_off
            numbits -= 8 - bit_off
            while (numbits >= 8):
                self.data[byte_off] = v & 0xff
                byte_off += 1
                v >>= 8
                numbits -= 8
                pass
            mask = 0xff << numbits
            x = self.data[byte_off]
            x &= mask
            x |= v & ~mask;
            self.data[byte_off] = x
            pass
        pass

    def get_bits(self, addr, num):
        v = 0
        for a in addr.entries:
            byte_off = a[0]
            bit_off = a[1] + a[3] * num
            byte_off += bit_off / 8
            bit_off %= 8
            numbits = a[2]
            v <<= numbits

            if (addr.revbits):
                # FIXME - This doesn't work for multi-byte revbits
                x = self.data[byte_off] >> (8 - numbits - bit_off)
            else:
                x = self.data[byte_off] >> bit_off
                pass
            bitsleft = numbits - (8 - bit_off)
            while (bitsleft >= 8):
                byte_off += 1
                x <<= 8
                x |= self.data[byte_off]
                bitsleft -= 8
                pass
            if (bitsleft > 0):
                byte_off += 1
                x <<= bitsleft
                if (addr.revbits):
                    x1 = self.data[byte_off] >> (8 - bitsleft)
                    x1 &= ~(0xffffffff << bitsleft)
                    x |= x1
                else:
                    x |= self.data[byte_off] & ~(0xffffffff << bitsleft)
                    pass
                pass
            v |= x & ~(0xffffffff << numbits)
            pass
        return v

    def set_bits(self, vt, addr, num):
        self.changed = True
        bitsleft = 0
        for a in addr.entries:
            bitsleft += a[2]
            pass
        for a in addr.entries:
            byte_off = a[0]
            bit_off = a[1] + a[3] * num
            byte_off += bit_off / 8
            bit_off %= 8
            numbits = a[2]
            bitsleft -= numbits

            v = vt >> bitsleft
            v = v & ~(0xffffffff << numbits)
        
            x = self.data[byte_off]
            if ((bit_off + numbits) <= 8):
                # Special case, all in one byte
                if (addr.revbits):
                    mask = (0xff >> (8 - numbits)) << (8 - numbits - bit_off)
                else:
                    mask = (0xff >> (8 - numbits)) << bit_off
                    pass
                x &= ~mask
                if (addr.revbits):
                    x |= (v << (8 - numbits - bit_off)) & mask
                else:
                    x |= (v << bit_off) & mask
                    pass
                self.data[byte_off] = x
                continue
            # FIXME - no support for the 'r' flag in the following.
            mask = 0xff << bit_off
            x &= ~mask
            self.data[byte_off] = x | ((v >> (numbits - (8 -bit_off))) & mask)
            self.data[byte_off] &= 0xff
            byte_off += 1
            numbits -= 8 - bit_off
            while (numbits >= 8):
                self.data[byte_off] = (v >> (numbits - 8)) & 0xff
                self.data[byte_off] &= 0xff
                byte_off += 1
                numbits -= 8
                pass
            if (numbits > 0):
                mask = 0xff << numbits
                x = self.data[byte_off]
                x &= mask
                x |= v & ~mask;
                self.data[byte_off] = x & 0xff
                pass
            pass
        pass

    def get_bytes(self, addr, num):
        byte_pos = addr.entries[0][0] + (addr.entries[0][3] * num / 8)
        numbytes = addr.entries[0][2] / 8
        return self.data[byte_pos:byte_pos+numbytes]

    def set_byte(self, v, addr, num, offset):
        byte_pos = addr.entries[0][0] + (addr.entries[0][3] * num / 8)
        self.changed = True
        self.data[byte_pos + offset] = v
        pass

    def get_string(self, addr, num):
        if (len(addr) != 1):
            raise DataException("String formats only support one"
                                + " location field")
        if (addr[0][2] != 0):
            raise DataException("String formats must of a zero bit offset")
        if ((addr[0][3] % 8) != 0):
            raise DataException("String formats must have a byte-multiple"
                                + " offset")
        byte_off = addr[0][0] + (addr[0][3] * num / 8)
        numbytes = addr[0][2]

        s = []
        for i in (0, numbyte):
            s.append(chr(self.data[byte_off+i]))
            pass
        for i in range(0, len(s)):
            if (s[i] not in ys_chars):
                if (s[i].islower()):
                    s[i] = s[i].upper()
                    continue
                s[i] = ' '
                pass
            pass
        s = "".join(s)
        return s
    
    def set_string(self, v, addr, num):
        if (len(addr) != 1):
            raise DataException("String formats only support one"
                                + " location field")
        if (addr[0][2] != 0):
            raise DataException("String formats must of a zero bit offset")
        if ((offset % 8) != 0):
            raise DataException("String formats must have a byte-multiple"
                                + " offset")
        byte_off = addr[0][0] + (addr[0][3] * num / 8)
        numbytes = addr[0][2]

        self.changed = True
        inlen = len(v)
        for i in range(0, numbytes):
            if (i >= inlen):
                c = " "
            else:
                c = v[i]
                pass
            if c not in ys_chars:
                c = " "
                pass
            self.data[byte_off] = ord(c)
            byte_off += 1
            pass
        pass
    
    pass


class HandlerTie:
    def __init__(self, handler, widget):
        self.handler = handler
        self.widget = widget
        return
    pass

class Handler:
    """This is an internal type that eases handling events for a type.
    The type objects do not own the data about the particular object
    they are used to represent, since they are reused fo rmany
    different objects.  Instead, when a widget is allocated to handle
    a particular type, one of these is allocated to hold that data and
    deliver it to the type object."""
    def __init__(self, handler, data):
        self.handler = handler
        self.data = data

        # The set of widgets/handlers we are tied to.  When the widget
        # associated with this handler changes, we call everything in
        # the tie list.  This is a list of HandlerTie object.
        self.tielist = []
        pass

    def addTie(self, h, w):
        self.tielist.append(HandlerTie(h, w))
        return

    # Called when the user modifies a value.  Not required for setValue
    # because that does a full redisplay.  Causes any tied values to be
    # redisplayed.
    def modified(self):
        for i in self.tielist:
            i.widget.renumWidget(i.handler, i.handler.num)
            pass
        return
    
    def set(self):
        self.handler(self)
        pass

    def set_event(self, event):
        return self.handler(self, event)

    pass

class BuiltIn:
    def __init__(self, name):
        self.name = name

        # A set of alternate names for this type, where selection might
        # occur from
        self.altnames = []
        pass

    def matchName(self, c, string):
        if (self.name == string):
            return self
        return None

    def getWidgetHandler(self, parent, t, num):
        h = Handler(None, None)
        h.widget = Tix.Label(parent)
        return h

    def renumWidget(self, h, num):
        pass

    def checkAddrOk(self, c, addr):
        return True

    def getSelect(self, data, addr, num):
        return ""
    
    def setValue(self, v, data, addr, num):
        pass

    pass

class BIString(BuiltIn):
    def __init__(self):
        BuiltIn.__init__(self, "String")
        pass

    def checkAddrOk(self, c, addr):
        if (len(addr.entries) != 1):
            raise ParseException(c.filename, c.lineno,
                                 "String formats only support one"
                                + " location field")
        if (addr.entries[0][1] != 0):
            raise ParseException(c.filename, c.lineno,
                                 "String formats must have a zero bit"
                                 + " offset")
        if ((addr.entries[0][2] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "String formats must be a"
                                 + " byte-multiple size")
        if ((addr.entries[0][3] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "String formats must have a"
                                 + " byte-multiple offset")
        return True

    def get_string(self, data, addr, num):
        s = data.get_bytes(addr, num)
        for i in range(0, len(s)):
            if (chr(s[i]) not in ys_chars):
                s[i] = ' '
            else:
                s[i] = chr(s[i])
                pass
            pass
        s = "".join(s)
        return s

    def set_string(self, v, data, addr, num, h):
        numbytes = addr.entries[0][2] / 8
        inlen = len(v)
        for i in range(0, numbytes):
            if (i >= inlen):
                p = " "
            else:
                p = v[i].upper()
                pass
            data.set_byte(ord(p), addr, num, i)
            pass
        if (h):
            h.modified()
            pass
        pass

    def getWidgetHandler(self, parent, t, num):
        v = self.get_string(t.data, t.addr, num)
        h = Handler(self.set, t)
        h.v = v
        h.num = num
        w = Tix.Entry(parent)
        h.widget = w
        w.bind("<KeyRelease>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, v)
        return h

    def renumWidget(self, h, num):
        h.num = num
        t = h.data
        v = self.get_string(t.data, t.addr, num)
        h.widget.delete(0, 'end')
        h.widget.insert(0, v)
        pass
        
    def getSelect(self, data, addr, num):
        return self.get_string(data, addr, num)

    def setValue(self, v, data, addr, num):
        self.set_string(v, data, addr, num, None)
        pass

    def set(self, h, event):
        w = h.widget
        t = h.data
        v = w.get()
        if (v == h.v):
            return
        cursor = w.index("insert")
        self.set_string(v, t.data, t.addr, h.num, h)
        v = self.get_string(t.data, t.addr, h.num)
        w.delete(0, 'end')
        w.insert(0, v)
        w.icursor(cursor)
        h.v = v
        pass
    pass


class BIFixed(BuiltIn):
    def __init__(self):
        self.name = "" # Name doesn't matter
        pass

    def setup(self, pre, suf, inc, units, snddec):
        # Number of digits to the left of the decimal
        self.pre = pre
        # Number of digits to the right of the decimal
        self.suf = suf
        # Each integer increment adds this much
        self.inc = inc
        # Units (like kHz, MHz, etc)
        self.units = units
        # Second decimal place location, -1 for none
        self.snddec = snddec

        self.numdec = 1

        # Total string length is prefix + suffix + the period
        self.len = pre + suf + 1
        if (self.snddec >= 0):
            self.snddec += 1 # Account for the first '.'
            self.len += 1
            self.numdec += 1
        pass

    def matchName(self, c, string):
        if not string.startswith("Fixed("):
            return None
        if not string.endswith(")"):
            raise ParseException(c.filename, c.lineno,
                                 "Fixed does not end with ')'")
        spec = string[6:len(string)-1].split(",")
        if (len(spec) < 4) or (len(spec) > 5):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid Fixed specifier")
        pre = c.toNum(spec[0])
        suf = c.toNum(spec[1])
        inc = c.toNum(spec[2])
        units = spec[3]
        snddec = -1
        if (len(spec) >= 5):
            opts = spec[4].split(":")
            for opt in opts:
                o = opt.split("=", 1)
                if (o[0] == "sd"):
                    if (len(o) != 2):
                        raise ParseException(c.filename, c.lineno,
                                             "sd option requires value")
                    snddec = c.toNum(o[1])
                    if (snddec <= pre or snddec > (pre + suf)):
                        raise ParseException(c.filename, c.lineno,
                                             "sd option must be after pre"
                                             + " and before the end of the"
                                             + " number")
                    pass
                else:
                    raise ParseException(c.filename, c.lineno,
                                         "Invalid Fixed option: " + o[0])
                pass
            pass
        b = BIFixed()
        b.setup(pre, suf, inc, units, snddec)
        return b

    def getWidgetHandler(self, parent, t, num):
        v = t.data.get_bits(t.addr, num)
        h = Handler(self.set, t)
        w = Tix.Entry(parent)
        h.widget = w
        h.num = num
        w.bind("<Key>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, self.conv_to_str(v))
        return h

    def renumWidget(self, h, num):
        h.num = num
        t = h.data
        v = t.data.get_bits(t.addr, num)
        h.widget.delete(0, 'end')
        h.widget.insert(0, self.conv_to_str(v))
        pass
        
    def getSelect(self, data, addr, num):
        return self.conv_to_str(data.get_bits( addr, num))

    def setValue(self, v, data, addr, num):
        data.set_bits(self.conv_from_str(v), addr, num)
        pass

    def set(self, h, event):
        if ((event.keysym == "BackSpace") or (event.keysym == "Delete")
            or (event.keysym == "Insert") or (event.keysym == "space")):
            return "break" # Don't allow deletions
        if (len(event.keysym) > 1):
            return # Let other key editing through

        # Now we have normal character keys.  Ignore everything but
        # digits, don't go past the end or change the "."

        w = h.widget
        cursor = w.index("insert")
        if (cursor >= self.len):
            return "break" # Past the end of the entry
        if (cursor == self.pre) or (cursor == self.snddec):
            w.icursor(cursor + 1) # Skip over the '.'
            return "break"

        c = event.keysym
        if (c not in decimal_digits):
            return "break" # Ignore everything but numbers

        t = h.data
        s = w.get()
        if (s[cursor] != c):
            s = s[0:cursor-1] + c + s[cursor:]
            w.delete(cursor)
            w.insert(cursor, c)
            v = self.conv_from_str(w.get())
            t.data.set_bits(v, t.addr, h.num)
            h.modified()
            s = self.conv_to_str(v)
            h.widget.delete(0, 'end')
            w.insert(0, s)
            pass
        if (cursor == self.pre - 1) or (cursor == self.snddec - 1):
            w.icursor(cursor + 2) # Skip over the '.'
        else:
            w.icursor(cursor + 1)
        return "break"

    def conv_from_str(self, s):
        v = 0
        l = 0
        decloc = -1
        postdec = 0
        units = None
        for c in s:
            if (c == '.'):
                if (decloc == -1):
                    decloc = l
                    pass
                continue
            d = decimal_digits.find(c)
            if (d == -1):
                # Must be in the units
                units = s[l:]
                if (decloc == -1):
                    decloc = l
                    pass
                break
            if (decloc != -1):
                postdec += 1
                pass
            v *= 10
            v += d
            l += 1
            pass
        if (decloc == -1):
            decloc = l
            pass
        if (units and units != self.units):
            # Need to do a units conversion.
            if (self.units == "MHz"):
                if (units == "kHz"):
                    decloc -= 3
                    postdec += 3
                elif (units == "Hz"):
                    decloc -= 6
                    postdec += 6
                    pass
                pass
            elif (self.units == "kHz"):
                if (units == "MHz"):
                    decloc += 3
                    postdec -= 6
                elif (units == "Hz"):
                    decloc -= 3
                    postdec += 3
                    pass
                pass
            pass
        if (postdec > self.suf):
            v /= 10 * (postdec - self.suf)
        elif (postdec < self.suf):
            v *= 10 * (self.suf - postdec)
            pass
        
        # Make sure to round as necessary
        return (v + (self.inc / 2)) / self.inc

    def conv_to_str(self, v):
        s = str(v * self.inc)
        while (len(s) < (self.len - self.numdec)):
            s = "0" + s
            pass
        s = s[0:self.len - self.numdec]
        s = s[0:self.pre] + "." + s[self.pre:] + self.units
        if (self.snddec != -1):
            s = s[0:self.snddec] + "." + s[self.snddec:]
            pass
        return s
    pass

class BICheckBox(BuiltIn):
    def __init__(self):
        BuiltIn.__init__(self, "CheckBox")
        pass

    def getWidgetHandler(self, parent, t, num):
        v = t.data.get_bits(t.addr, num)
        h = Handler(self.set, t)
        w = Tix.Checkbutton(parent, command=h.set)
        h.num = num
        h.widget = w
        h.v = v
        if (v):
            w.select()
        else:
            w.deselect()
            pass
        return h

    def renumWidget(self, h, num):
        h.num = num
        t = h.data
        v = t.data.get_bits(t.addr, num)
        if (v):
            h.widget.select()
        else:
            h.widget.deselect()
            pass
        pass
        
    def set(self, h):
        w = h.widget
        t = h.data
        if (h.v):
            h.v = 0
        else:
            h.v = 1
            pass
        t.data.set_bits(h.v, t.addr, h.num)
        h.modified()
        pass

    def getSelect(self, data, addr, num):
        v = data.get_bits(addr, num)
        if (v):
            return '1'
        else:
            return '0'
    
    def setValue(self, v, data, addr, num):
        if (v == "0"):
            data.set_bits(0, addr, num)
        elif (v == "1"):
            data.set_bits(1, addr, num)
            pass
        pass
    
    pass

class BIYaesuString(BuiltIn):
    def __init__(self):
        BuiltIn.__init__(self, "YaesuString")
        pass

    def checkAddrOk(self, c, addr):
        if (len(addr.entries) != 1):
            raise ParseException(c.filename, c.lineno,
                                 "Yaesu string formats only support one"
                                + " location field")
        if (addr.entries[0][1] != 0):
            raise ParseException(c.filename, c.lineno,
                                 "Yaesu string formats must have a zero bit"
                                 + " offset")
        if ((addr.entries[0][2] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "Yaesu string formats must be a"
                                 + " byte-multiple size")
        if ((addr.entries[0][3] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "Yaesu string formats must have a"
                                 + " byte-multiple offset")
        return True

    def get_yaesu_string(self, data, addr, num):
        s = data.get_bytes(addr, num)
        for i in range(0, len(s)):
            if (s[i] > 0x3f):
                s[i] = ' '
            else:
                s[i] = ys_chars[s[i]]
                pass
            pass
        s = "".join(s)
        return s

    def set_yaesu_string(self, v, data, addr, num, h):
        numbytes = addr.entries[0][2] / 8
        inlen = len(v)
        for i in range(0, numbytes):
            if (i >= inlen):
                p = 0x24
            else:
                p = ys_chars.find(v[i].upper())
                if (p < 0):
                    p = 0x24
                    pass
                pass
            data.set_byte(p, addr, num, i)
            pass
        if (h):
            h.modified()
            pass
        pass

    def getWidgetHandler(self, parent, t, num):
        v = self.get_yaesu_string(t.data, t.addr, num)
        h = Handler(self.set, t)
        h.v = v
        h.num = num
        w = Tix.Entry(parent)
        h.widget = w
        w.bind("<KeyRelease>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, v)
        return h

    def renumWidget(self, h, num):
        h.num = num
        t = h.data
        v = self.get_yaesu_string(t.data, t.addr, num)
        h.widget.delete(0, 'end')
        h.widget.insert(0, v)
        pass
        
    def getSelect(self, data, addr, num):
        return self.get_yaesu_string(data, addr, num)

    def setValue(self, v, data, addr, num):
        self.set_yaesu_string(v, data, addr, num, None)
        pass

    def set(self, h, event):
        w = h.widget
        t = h.data
        v = w.get()
        if (v == h.v):
            return
        cursor = w.index("insert")
        self.set_yaesu_string(v, t.data, t.addr, h.num, h)
        v = self.get_yaesu_string(t.data, t.addr, h.num)
        w.delete(0, 'end')
        w.insert(0, v)
        w.icursor(cursor)
        h.v = v
        pass
    pass

def convFromBCD(v):
    if (v >= 10) or (v < 0):
        return '0'
    return decimal_digits[v]

# Yaesu BCD format for frequency, see FT60-layout.txt
# FIXME - This does not properly do the 2.5kHz steps.
class BIBCDFreq(BuiltIn):
    def __init__(self):
        BuiltIn.__init__(self, "BCDFreq")
        pass

    def checkAddrOk(self, c, addr):
        if (len(addr.entries) != 1):
            raise ParseException(c.filename, c.lineno,
                                 "BCDFreq formats only support one"
                                + " location field")
        if (addr.entries[0][1] != 0):
            raise ParseException(c.filename, c.lineno,
                                 "BCDFreq formats must have a zero bit"
                                 + " offset")
        if (addr.entries[0][2] != 24):
            raise ParseException(c.filename, c.lineno,
                                 "BCDFreq formats must be 24 bits long")
        if ((addr.entries[0][3] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "BCDFreq formats must have a"
                                 + " byte-multiple offset")
        return True

    def get_bcd(self, data, addr, num):
        s = data.get_bytes(addr, num)
        v = [ ]
        i = 0
        add5 = s[i] >> 4
        v.append(convFromBCD(s[i] & 0xf))
        i += 1
        numbytes = 3
        while (i < numbytes):
            v.append(convFromBCD(s[i] >> 4))
            v.append(convFromBCD(s[i] & 0xf))
            i += 1
            pass
        if (add5):
            v.append('5')
        else:
            v.append('0')
            pass
        v.insert(3, '.')
        return "".join(v)
        pass

    # Yaesu BCD format for frequency, see FT60-layout.txt
    def set_bcd(self, v, data, addr, num, h):
        numbytes = addr.entries[0][2] / 8

        vlen = len(v)
        add5 = v[vlen - 1] >= '5'
        if (add5):
            d = 0x8
        else:
            d = 0
            pass
        second = True
        i = 0
        for c in v[0:vlen - 1]:
            if c == '.':
                continue
            if (second):
                d <<= 4
                d |= decimal_digits.find(c)
                second = False
                data.set_byte(d, addr, num, i)
                i += 1
                pass
            else:
                d = decimal_digits.find(c)
                second = True
                pass
            pass
        if (h):
            h.modified()
            pass
        pass

    def getWidgetHandler(self, parent, t, num):
        v = self.get_bcd(t.data, t.addr, num)
        h = Handler(self.set, t)
        w = Tix.Entry(parent)
        h.widget = w
        h.num = num
        w.bind("<Key>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, v)
        return h

    def renumWidget(self, h, num):
        h.num = num
        t = h.data
        v = self.get_bcd(t.data, t.addr, num)
        h.widget.delete(0, 'end')
        h.widget.insert(0, v)
        pass
        
    def getSelect(self, data, addr, num):
        # Note that we pad it out to Hz for copy/paste, for compatability
        return self.get_bcd(data, addr, num) + ".000"

    def set(self, h, event):
        if ((event.keysym == "BackSpace") or (event.keysym == "Delete")
            or (event.keysym == "Insert") or (event.keysym == "space")):
            return "break" # Don't allow deletions
        if (len(event.keysym) > 1):
            return # Let other key editing through

        # Now we have normal character keys.  Ignore everything but
        # digits, don't go past the end or change the "."

        w = h.widget
        cursor = w.index("insert")
        if (cursor >= 7):
            return "break" # Past the end of the entry
        if (cursor == 3):
            w.icursor(cursor + 1) # Skip over the '.'
            return "break"

        c = event.keysym
        if (c not in decimal_digits):
            return "break" # Ignore everything but numbers

        if (cursor == 6):
            # Last digit can only be 0 or 5
            if (c < '5'):
                c = '0'
            else:
                c = '5'
                pass
            pass
                
        s = w.get()
        if (s[cursor] != c):
            w.delete(cursor)
            w.insert(cursor, c)
            self.set_bcd(w.get(), t.data, t.addr, h.num, h)
            pass
        if (cursor == 2):
            w.icursor(cursor + 2) # Skip over the '.'
        else:
            w.icursor(cursor + 1)
        return "break"

    def setValue(self, v, data, addr, num):
        firstc = False
        c2 = [ ]
        for c in v:
            if ((c != '.') and (c not in decimal_digits)):
                return
            if (c == '.'): # Cut off the last .nnn, if present
                if (firstc):
                    break;
                firstc = True;
                pass
            c2.append(c)
            pass

        v = "".join(c2)
        self.set_bcd(v, data, addr, num, None)
        pass
    pass

hex_digits = "0123456789ABCDEF "
def convFromHex(v):
    if (v == 0xff):
        return ' '
    if (v >= 16) or (v < 0):
        return '0'
    return hex_digits[v]

class BIHex(BuiltIn):
    def __init__(self):
        BuiltIn.__init__(self, "HexDigits")
        pass

    def checkAddrOk(self, c, addr):
        if (len(addr.entries) != 1):
            raise ParseException(c.filename, c.lineno,
                                 "HexDigit formats only support one"
                                + " location field")
        if (addr.entries[0][1] != 0):
            raise ParseException(c.filename, c.lineno,
                                 "HexDigits formats must have a zero bit"
                                 + " offset")
        if ((addr.entries[0][2] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "HexDigits formats must have a"
                                 + " byte-multiple size")
        if ((addr.entries[0][3] % 8) != 0):
            raise ParseException(c.filename, c.lineno,
                                 "HexDigits formats must have a"
                                 + " byte-multiple offset")
        return True

    def get_hex(self, data, addr, num):
        s = data.get_bytes(addr, num)
        v = [ ]
        i = 0
        numbytes = addr.entries[0][2] / 8
        while (i < numbytes):
            v.append(convFromHex(s[i]))
            i += 1
            pass
        return "".join(v)
        pass

    def set_hex(self, v, data, addr, num, h):
        numbytes = addr.entries[0][2] / 8

        vlen = len(v)
        second = False
        i = 0
        for c in v:
            if (c == ' '):
                d = 0xff
            else:
                d = hex_digits.find(c)
            data.set_byte(d, addr, num, i)
            i += 1
            pass
        if (h):
            h.modified()
            pass
        pass

    def getWidgetHandler(self, parent, t, num):
        v = self.get_hex(t.data, t.addr, num)
        h = Handler(self.set, t)
        h.numbytes = t.addr.entries[0][2] / 8
        w = Tix.Entry(parent)
        h.widget = w
        h.num = num
        w.bind("<Key>", h.set_event)
        w.delete(0, 'end')
        w.insert(0, v)
        return h

    def renumWidget(self, h, num):
        h.num = num
        t = h.data
        v = self.get_hex(t.data, t.addr, num)
        h.widget.delete(0, 'end')
        h.widget.insert(0, v)
        pass
        
    def getSelect(self, data, addr, num):
        return self.get_hex(data, addr, num)

    def set(self, h, event):
        if ((event.keysym == "BackSpace") or (event.keysym == "Delete")
            or (event.keysym == "Insert")):
            return "break" # Don't allow deletions
        if (event.keysym == "space"):
            event.keysym = ' '
        elif (len(event.keysym) > 1):
            return # Let other key editing through

        # Now we have normal character keys.  Ignore everything but
        # digits, don't go past the end or change the "."

        w = h.widget
        cursor = w.index("insert")
        if (cursor >= h.numbytes):
            return "break" # Past the end of the entry

        c = event.keysym.upper()
        if (c != ' ' and c not in hex_digits):
            return "break" # Ignore everything but numbers and space

        t = h.data
        s = w.get()
        if (s[cursor] != c):
            w.delete(cursor)
            w.insert(cursor, c)
            self.set_hex(w.get(), t.data, t.addr, h.num, h)
            pass
        w.icursor(cursor + 1)
        return "break"

    def setValue(self, v, data, addr, num):
        for c in v:
            if (c not in decimal_digits):
                return
            pass

        self.set_hex(v, data, addr, num, None)
        pass
    pass

class MenuAndButton(Tix.Menubutton):
    def __init__(self, parent):
        Tix.Menubutton.__init__(self, parent)
        self.menu = Tix.Menu(self)
        self['menu'] = self.menu
        pass

    def add_command(self, name, handler):
        self.menu.add_command(label=name, command=handler)
        pass

    def set_label(self, label):
        self["text"] = label
    pass

class EnumEntry:
    def __init__(self, value, str):
        self.value = value
        self.str = str
        return
    pass

class Enum(BuiltIn):
    def __init__(self, name):
        BuiltIn.__init__(self, name)
        self.entries = []
        pass

    def add(self, c, v):
        if (v[0] == "endenum"):
            c.addEnum(self)
            return
        elif (v[0] == "altname"):
            if (len(v) < 2):
                raise ParseException(c.filename, c.lineno,
                                     "No alternate name given");
            self.altnames.append(v[1])
            return
        
        if (len(v) != 2):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid number of elements for enum");
        self.entries.append(EnumEntry(c.toNum(v[0]), v[1]))
        pass

    def getWidgetHandler(self, parent, t, num):
        toph = Handler(None, None)
        toph.widget = MenuAndButton(parent)
        toph.data = t.data
        toph.addr = t.addr
        toph.num = num
        v = t.data.get_bits(t.addr, num)
        for e in self.entries:
            h = Handler(self.set, e)
            h.toph = toph
            toph.widget.add_command(e.str, h.set)
            if (v == e.value):
                toph.widget.set_label(e.str)
                pass
            pass
        return toph

    def set(self, h):
        e = h.data
        h.toph.widget.set_label(e.str)
        h.toph.data.set_bits(e.value, h.toph.addr, h.toph.num)
        h.toph.modified()
        pass

    def renumWidget(self, toph, num):
        toph.num = num
        v = toph.data.get_bits(toph.addr, num)
        found = False
        for e in self.entries:
            if (v == e.value):
                found = True
                toph.widget.set_label(e.str)
                break
            pass
        if (not found):
            toph.widget.set_label("")
        pass

    def getSelect(self, data, addr, num):
        v = data.get_bits(addr, num)
        for e in self.entries:
            if (v == e.value):
                return e.str.replace(" ", "")
            pass
        pass

    def setValue(self, v, data, addr, num):
        for e in self.entries:
            if (v == e.str.replace(" ", "")):
                data.set_bits(e.value, addr, num)
                return
            pass
        pass
    
    pass


class TabEntry:
    def __init__(self, name, pos, addr, type, data, tielist_str, cutpaste):
        self.name = name
        self.pos = pos
        nn = self.name.replace("\n", "")
        nn = nn.replace(" ", "")
        nn = nn.replace("\t", "")
        self.nsname = nn
        self.addr = addr
        self.type = type
        self.data = data

        # The list of strings that we are tied to.  This is deleted when
        # we are done with it.
        self.tielist_str = tielist_str

        # The list of widgets we are tied to, generated later frome
        # the tielist_str.
        self.tielist = []
        
        self.cutpaste = cutpaste
        pass

    def getWidgetHandler(self, parent, num):
        return self.type.getWidgetHandler(parent, self, num)

    def renumWidget(self, h, num):
        self.type.renumWidget(h, num)
        pass

    def getSelect(self, num):
        v = self.type.getSelect(self.data, self.addr, num)
        if (v is None):
            v = ""
        return (self.nsname + "=" + v)

    def setSelect(self, num, vhash):
        if (self.nsname in vhash):
            v = vhash[self.nsname]
            del vhash[self.nsname]
            self.type.setValue(v, self.data, self.addr, num)
            pass
        else:
            for n in self.type.altnames:
                if (n in vhash):
                    v = vhash[n]
                    del vhash[n]
                    self.type.setValue(v, self.data, self.addr, num)
                    return
                pass
            pass
        pass
    
    pass

class TabBase:
    def __init__(self, name):
        self.name = name
        self.entries = []
        return

    def addItem(self, c, name, addr, type, tielist_str, cutpaste):
        type.checkAddrOk(c, addr)
        self.entries.append(TabEntry(name, len(self.entries), addr,
                                     type, c.filedata, tielist_str, cutpaste))
        return
    
    def finalize(self, c):
        for i in self.entries:
            for t in i.tielist_str:
                found = False
                for j in self.entries:
                    if (j.name == t):
                        i.tielist.append(j)
                        found = True
                        break
                    pass
                if (not found):
                    raise ParseException(c.filename, c.lineno,
                                         "tie entry for '" + t +"' not found")
                pass
            del i.tielist_str
            pass
        return
    
    pass

class List(TabBase):
    """This is a list widget rework to make an HList that only has the
    items being displayed as list entries.  If you add the entire lists and
    scroll it and there are a thousand entries, a standard scrolled hlist
    is too slow because of the tens of thousands of widgets created.  So
    this class only creates widgets for the dislayed amount, then it
    redoes what is in the widgets based upon the scroll position."""
    def __init__(self, name, length):
        TabBase.__init__(self, name)

        # Total length of elements in the list
        self.length = length

        # Number of lines currently displayed
        self.numdisplines = 0

        # Number of the first displayed line
        self.firstdispline = 0

        # A list of handlers for each displayed row
        self.handlerlists = []
        pass

    def add(self, c, v):
        if (v[0] == "endlist"):
            self.finalize(c)
            c.addList(self)
            return
        if (len(v) < 3):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid number of elements for list entry")
        ties = []
        cutpaste = True
        for i in v[3:]:
            s = i.split('=', 1)
            if len(s) != 2:
                raise ParseException(c.filename, c.lineno,
                                     "Invalid option, no '=': " + i)
            if (s[0] == "tie"):
                ties.append(s[1])
            elif (s[0] == "cutpaste"):
                if (s[1].lower() == "true"):
                    cutpaste = True
                elif (s[1].lower() == "false"):
                    cutpaste = False
                else:
                    raise ParseException(c.filename, c.lineno,
                                         "cutpaste take true or false")
            else:
                raise ParseException(c.filename, c.lineno,
                                     "Invalid option: " + i);
            pass
            
        self.addItem(c, v[0], Address(c, v[1]), c.findType(v[2]), ties,
                     cutpaste)
        pass

    def bindWidget(self, widget):
        widget.bind("<MouseWheel>", self.Wheel)
        widget.bind("<Down>", self.lineDown)
        widget.bind("<Up>", self.lineUp)
        widget.bind("<Next>", self.pageDown)
        widget.bind("<Prior>", self.pageUp)
        if (self.winsys == "x11"):
            widget.bind("<Button-4>", self.ButtonUpWheel)
            widget.bind("<Button-5>", self.ButtonDownWheel)
            pass
        pass
        
    def setup(self, top):
        try:
            self.winsys = top.tk.eval("return [ tk windowingsystem ]")
            pass
        except:
            # Assume x11
            self.winsys = "x11"
            pass

        self.xscroll = Tix.Scrollbar(top, orient=Tix.HORIZONTAL)
        self.yscroll = Tix.Scrollbar(top, orient=Tix.VERTICAL)
        self.list = Tix.HList(top, header=1, columns=len(self.entries) + 1,
                              itemtype="text", selectforeground="black",
                              selectbackground="beige",
                              yscrollcommand=self.y_scrolled,
                              xscrollcommand=self.xscroll.set)
        self.xscroll['command'] = self.list.xview
        self.yscroll['command'] = self.y_move
        self.xscroll.pack(side=Tix.BOTTOM, fill=Tix.X)
        self.yscroll.pack(side=Tix.RIGHT, fill=Tix.Y)

        self.list.selection_handle(self.selection_request)

        self.first_select = -1
        self.last_select = -1
        self.list.bind("<Button-1>", self.Button1)
        self.list.bind("<Shift-Button-1>", self.SButton1)
        self.list.bind("<Control-Button-1>", self.CButton1)
        self.list.bind("<Button-2>", self.Button2)
        self.list.bind("<Button-3>", self.Button3)

        self.list.bind("<Map>", self.mapped)

        self.bindWidget(self.list)
        self.bindWidget(self.xscroll)
        self.bindWidget(self.yscroll)
        
        i = 1
        for e in self.entries:
            e.column = i
            self.list.header_create(i, text=e.name)
            self.list.column_width(i, "")
            i += 1
            pass

        self.list.pack(side=Tix.LEFT, fill=Tix.BOTH, expand=1)
        pass

    def mapped(self, event=None):
        self.list.focus_set()
        return
        
    def selection_request(self, a, b):
        if (self.first_select < 0):
            return ""
        s = ""
        for i in range(self.first_select, self.last_select + 1):
            if (s):
                s += "\n"
                pass
            first = True
            for e in self.entries:
                if (not e.cutpaste):
                    continue
                if (not first):
                    s += " "
                else:
                    first = False
                    pass
                s += e.getSelect(i)
                pass
            pass
        return s

    def redoSelection(self):
        if ((self.last_select < self.firstdispline)
            or (self.first_select >= self.firstdispline + self.numdisplines)):
            # Nothing to see
            self.list.selection_clear()
            return
        
        if (self.first_select <= self.firstdispline):
            pos1 = 0
        else:
            pos1 = self.first_select - self.firstdispline
            pass
        
        end = self.firstdispline + self.numdisplines - 1
        if (self.last_select >= end):
            pos2 = self.numdisplines - 1
        else:
            pos2 = self.last_select - self.firstdispline
            pass

        self.list.selection_clear()
        self.list.selection_set(pos1, pos2)
        self.list.selection_own()
        pass
    
    def Button1(self, event):
        self.list.focus_set()
        line = int(self.list.nearest(event.y))
        self.first_select = self.firstdispline + line
        self.last_select = self.firstdispline + line
        self.redoSelection()
        return "break"
    
    def SButton1(self, event):
        if (self.first_select < 0):
            return self.Button1(event)
        line = int(self.list.nearest(event.y))
        pos = line + self.firstdispline
        if (pos < self.first_select):
            self.first_select = pos
        else:
            self.last_select = pos
            pass
        self.redoSelection()
        return "break"
    
    def CButton1(self, event):
        return "break"
    
    def Button2(self, event):
        linenum = int(self.list.nearest(event.y)) + self.firstdispline
        s = self.list.selection_get()
        lines = s.split("\n")
        for l in lines:
            if (linenum >= self.length):
                return
            vhash = {}
            for vp in l.split():
                v = vp.split("=")
                if (len(v) != 2):
                    continue
                vhash[v[0]] = v[1]
                pass
            for e in self.entries:
                if (e.cutpaste):
                    e.setSelect(linenum, vhash)
                    pass
                pass
            linenum += 1
            pass
        self.redisplay()
        return "break"
    
    def Button3(self, event):
        self.first_select = -1
        self.last_select = -1
        self.redoSelection()
        return "break"
    
    def Wheel(self, event):
        self.y_move("scroll", -(event.delta / 20), "units")
        return
    
    def ButtonUpWheel(self, event):
        event.delta = 120
        self.Wheel(event);
        return
    
    def ButtonDownWheel(self, event):
        event.delta = -120
        self.Wheel(event);
        return
    
    def y_scrolled(self, a, b):
        b = float(b)
        if (self.numdisplines < self.length) and (b >= 1.0):
            self.add_one_line()
        elif ((self.numdisplines > 0)
              and (b < (1.0 - (1.0 / float(self.numdisplines))))):
            self.del_one_line()
        else:
            pct = float(self.numdisplines) / float(self.length)
            first = float(self.firstdispline) / float(self.length)
            self.yscroll.set(first, first + pct)
            pass
        self.redoSelection()
        pass

    def pageDown(self, event=None):
        self.y_move("scroll", 1, "pages")
        return "break"
    
    def pageUp(self, event=None):
        self.y_move("scroll", -1, "pages")
        return "break"
    
    def lineDown(self, event=None):
        self.y_move("scroll", 1, "units")
        return "break"
    
    def lineUp(self, event=None):
        self.y_move("scroll", -1, "units")
        return "break"
    
    def y_move(self, a, b=None, c=None):
        if (a == "scroll"):
            if (c == "units"):
                if (int(b) < 0):
                    if (self.firstdispline > 0):
                        self.firstdispline -= 1
                        self.redisplay()
                        pass
                    pass
                else:
                    if ((self.firstdispline + self.numdisplines)
                        < self.length):
                        self.firstdispline += 1
                        self.redisplay()
                        pass
                    pass
                pass
            elif (c == "pages"):
                if (int(b) < 0):
                    if (self.firstdispline > (self.numdisplines - 1)):
                        self.firstdispline -= self.numdisplines - 1
                        self.redisplay()
                    elif (self.firstdispline > 0):
                        self.firstdispline = 0
                        self.redisplay()
                        pass
                    pass
                else:
                    if (self.firstdispline + (2 * self.numdisplines) - 1
                        <= self.length):
                        self.firstdispline += self.numdisplines - 1
                        self.redisplay()
                    elif (self.firstdispline + self.numdisplines
                          <= self.length):
                        self.firstdispline = self.length - self.numdisplines
                        self.redisplay()
                        pass
                    pass
                pass
        elif (a == "moveto"):
            pct = float(b)
            fl = int(pct * float(self.length))
            if ((fl != self.firstdispline)
                and (fl >= 0)
                and ((fl + self.numdisplines) <= self.length)):
                self.firstdispline = fl
                self.redisplay()
                pass
            pass
        pass

    def redisplay(self):
        i = 0
        for wl in self.handlerlists:
            self.list.item_configure(i, 0,
                                     text=str(i + self.firstdispline + 1))
            for e in self.entries:
                e.renumWidget(wl[e.pos], i + self.firstdispline)
            i += 1
            pass
        pass
    
    def add_one_line(self):
        handlers = []
        pos = self.firstdispline + self.numdisplines
        self.list.add(self.numdisplines, text=str(pos + 1))
        for e in self.entries:
            h = e.getWidgetHandler(self.list, pos)
            h.ename = e.name
            self.bindWidget(h.widget)
            self.list.item_create(self.numdisplines, e.column,
                                  itemtype=Tix.WINDOW,
                                  window=h.widget)
            handlers.append(h)
            pass
        for e in self.entries:
            for i in e.tielist:
                handlers[e.pos].addTie(handlers[i.pos], i)
                pass
            pass
        self.handlerlists.append(handlers)
        self.numdisplines += 1
        pass
        
    def del_one_line(self):
        if (self.numdisplines < 0):
            return
        self.numdisplines -= 1
        del self.handlerlists[self.numdisplines]
        self.list.delete_entry(self.numdisplines)
        pass
    
    pass

class Tab(TabBase):
    def __init__(self, name):
        self.name = name
        self.entries = []
        pass

    def add(self, c, v):
        if (v[0] == "endtab"):
            self.finalize(c)
            c.addTab(self)
            return
        if (len(v) < 3):
            raise ParseException(c.filename, c.lineno,
                                 "Invalid number of elements for tab entry");
        ties = []
        cutpaste = True
        for i in v[3:]:
            s = i.split('=', 1)
            if len(s) != 2:
                raise ParseException(c.filename, c.lineno,
                                     "Invalid option, no '=': " + i)
            if (s[0] == "tie"):
                ties.append(s[1])
            elif (s[0] == "cutpaste"):
                if (s[1].lower() == "true"):
                    cutpaste = True
                elif (s[1].lower() == "false"):
                    cutpaste = False
                else:
                    raise ParseException(c.filename, c.lineno,
                                         "cutpaste take true or false")
            else:
                raise ParseException(c.filename, c.lineno,
                                     "Invalid option: " + i);
            pass

        self.addItem(c, v[0], Address(c, v[1]), c.findType(v[2]), ties,
                     cutpaste)
        pass

    def bindWidget(self, widget):
        widget.bind("<MouseWheel>", self.Wheel)
        if (self.winsys == "x11"):
            widget.bind("<Button-4>", self.ButtonUpWheel)
            widget.bind("<Button-5>", self.ButtonDownWheel)
            pass
        pass
        
    def Wheel(self, event):
        self.list.hlist.yview("scroll", -(event.delta / 20), "units")
        return
    
    def ButtonUpWheel(self, event):
        event.delta = 120
        self.Wheel(event);
        return
    
    def ButtonDownWheel(self, event):
        event.delta = -120
        self.Wheel(event);
        return
    
    def setup(self, top):
        try:
            self.winsys = top.tk.eval("return [ tk windowingsystem ]")
            pass
        except:
            # Assume x11
            self.winsys = "x11"
            pass

        self.list = Tix.ScrolledHList(top, scrollbar="auto",
                                      options="hlist.header 1"
                                      + " hlist.columns 2"
                                      + " hlist.itemtype text"
                                      + " hlist.selectForeground black"
                                      + " hlist.selectBackground beige")
        self.list.hlist.header_create(0, text="Name")
        self.list.hlist.header_create(1, text="Value")
        self.list.hlist.column_width(0, "")
        self.list.hlist.column_width(1, "")
        self.bindWidget(self.list)
        self.bindWidget(self.list.hlist)
        self.bindWidget(self.list.hsb)
        self.bindWidget(self.list.vsb)

        i = 0
        handlers = []
        for e in self.entries:
            e.key = i
            self.list.hlist.add(i, text=e.name)
            h = e.getWidgetHandler(self.list.hlist, i)
            self.list.hlist.item_create(i, 1, itemtype=Tix.WINDOW,
                                        window=h.widget)
            self.bindWidget(h.widget)
            handlers.append(h)
            i += 1
            pass
        for e in self.entries:
            for i in e.tielist:
                handlers[e.pos].addTie(handlers[i.pos], i)
                pass
            pass

        self.list.pack(side=Tix.LEFT, fill=Tix.BOTH, expand=1)
        pass

    pass

quote_hash = {"n" : "\n",
              "t" : "\t",
              "r" : "\r" }

def unquote(s):
    inquote = False
    v = []
    for c in s:
        if (inquote):
            if (c in quote_hash):
                v.append(quote_hash[c])
            else:
                v.append(c);
                pass
            inquote = False
            pass
        elif (c == '\\'):
            inquote = True
            pass
        else:
            v.append(c)
            pass
        pass
    return "".join(v)

class LineNum:
    def __init__(self):
        self.val = 0
        return
    
    def get(self):
        return self.val

    def inc(self):
        self.val += 1
        return
    pass

class RadioConfig:
    def __init__(self, filename, filedata, parent=None, name=None):
        self.filename = filename
        self.filedata = filedata
        self.parent = parent
        self.name = name
        self.curr = None
        self.toplevel = []
        if (parent):
            self.types = self.parent.types
            self.infile = parent.infile
            self.lineno = parent.lineno
        else:
            self.types = [ BIBCDFreq(),
                           BICheckBox(), BIYaesuString(),
                           BIString(), BuiltIn("Empty"),
                           BIHex(), BIFixed() ]
            self.infile = open(filename, "r")
            self.lineno = LineNum()
            pass
        try:
            while True:
                l = self.infile.readline();
                if (not l):
                    break
                self.lineno.inc()
                if l[0] == '#':
                    continue
                v = self.splitup_line(l);
                if (not v):
                    continue
                if (v[0] == "endmulti"):
                    if (not self.parent):
                        raise ParseException(self.filename, self.lineno,
                                             "got endmulti, but not in multi")
                    self.parent.addMulti(self)
                    return
                
                self.parseLine(v)
                pass
            pass
        except Exception, e:
            exceptionType, exceptionValue, exceptionTraceback = sys.exc_info()
            self.infile.close()
            raise exceptionType, exceptionValue, exceptionTraceback
        self.infile.close()
        pass

    def add(self, c, v):
        raise ParseException(c.filename, c.lineno,
                             "Can't add elements to a multi");
        pass

    def toNum(self, s):
        # Eliminate leading zeros
        i = 0
        l = len(s)
        if (l == 0):
            raise ParseException(self.filename, self.lineno,
                                 "Invalid number")
        while ((i < l) and (s[i] == '0')):
            i += 1
            pass
        if (i == l):
            return 0
        if ((i > 0) and (s[i] == 'x')):
            i -= 1
            pass
        try:
            v = int(s[i:], 0)
        except TypeError, e:
            raise ParseException(self.filename, self.lineno,
                                 "Invalid number")
        except ValueError, e:
            raise ParseException(self.filename, self.lineno,
                                 "Invalid number")
        return v

    def splitup_line(self, l):
        v = []
        instr = False
        inname = False
        inquote = False
        i = 0
        last = len(l)
        start = 0
        while (i < last):
            c = l[i]
            if (inquote):
                inquote = False
                pass
            elif (instr and (c == '"')):
                v.append(unquote(l[start:i]))
                instr = False
            elif (inname and c.isspace()):
                v.append(unquote(l[start:i]))
                inname = False
            elif (c == '"'):
                start = i + 1
                instr = True
            elif (not (inname or instr) and not c.isspace()):
                if (c == '\\'):
                    inquote = True
                    pass
                start = i
                inname = True
            elif (c == '\\'):
                inquote = True
                pass
            i += 1
            pass

        if (inquote):
            raise ParseException(self.filename, self.lineno,
                                 "End of line after '\\'");
        if (instr):
            raise ParseException(self.filename, self.lineno,
                                 "End of line in string");
        if (inname):
            v.append(l[start:i])
        return v
    
    def parseLine(self, s):
        if (self.curr == None):
            if (s[0] == "enum"):
                if (len(s) < 2):
                    raise ParseException(self.filename, self.lineno,
                                         "Enum has no name")
                self.curr = Enum(s[1])
            elif (s[0] == "list"):
                if (len(s) < 2):
                    raise ParseException(self.filename, self.lineno,
                                         "List has no name")
                if (len(s) < 3):
                    raise ParseException(self.filename, self.lineno,
                                         "List has no length")
                length = self.toNum(s[2])
                self.curr = List(s[1], length)
            elif (s[0] == "tab"):
                if (len(s) < 2):
                    raise ParseException(self.filename, self.lineno,
                                         "Tab has no name")
                self.curr = Tab(s[1])
            elif (s[0] == "multi"):
                if (len(s) < 2):
                    raise ParseException(self.filename, self.lineno,
                                         "Multi has no name")
                RadioConfig(self.filename, self.filedata,
                            parent=self, name=s[1])
            else:
                raise ParseException(self.filename, self.lineno,
                                     "Invalid token: '" + s[0] + "'")
        else:
            self.curr.add(self, s)
            pass
        pass

    def addEnum(self, e):
        for i in self.types:
            if (i.name == e.name):
                raise ParseException(self.filename, self.lineno,
                                     "Duplicate type: " + e.name)
            pass
        self.types.append(e)
        self.curr = None
        pass

    def findType(self, s):
        for i in self.types:
            t = i.matchName(self, s)
            if (t):
                return t
            pass
        raise ParseException(self.filename, self.lineno, "Unknown type: " + s)
    
    def addList(self, e):
        self.toplevel.append(e)
        self.curr = None
        pass

    def addTab(self, e):
        self.toplevel.append(e)
        self.curr = None
        pass

    def addMulti(self, e):
        self.toplevel.append(e)
        self.curr = None
        pass

    def setup(self, pwid):
        self.tabs = Tix.NoteBook(pwid);
        self.tabs.pack(side=Tix.TOP, fill=Tix.BOTH, expand=1)
        for t in self.toplevel:
            t.tab = self.tabs.add(t.name.lower(), label=t.name)
            t.setup(t.tab)
            pass

    pass

class RadioSel:
    def __init__(self, parent, radio):
        self.parent = parent
        self.radio = radio
        return

    def selected(self):
        self.parent.newradio(self.radio)
        return
    pass

class IsOk(Tix.DialogShell):
    def __init__(self, text, command):
        Tix.DialogShell.__init__(self, name="quit OK?")
        w = Tix.Label(self, text=text)
        w.pack(side=Tix.TOP, fill=Tix.BOTH, expand=1, )
        self.ok = Tix.Button(self, text='Ok', command=self.ok);
        self.ok.pack(side=Tix.LEFT, expand=1, padx=10, pady=8)
        self.cancel = Tix.Button(self, text='Cancel', command=self.cancel);
        self.cancel.pack(side=Tix.LEFT, expand=1, padx=10, pady=8)
        self.popup()
        self.command = command
        return

    def ok(self):
        self.popdown()
        self.command(True)
        return

    def cancel(self):
        self.destroy()
        self.command(False)
        return

    pass

class GUI(Tix.Frame):
    def __init__(self, filename=None, master=None):
        Tix.Frame.__init__(self, master)
        self.top = master
        self.pack(fill=Tix.BOTH, expand=1);
        master.geometry('800x400')
        self.createWidgets();
        self.filedialog = Tix.FileSelectDialog(master,
                                               command=self.open_select)
        self.saveasdialog = Tix.FileSelectDialog(master,
                                                 command=self.saveas_select)
        if (filename):
            self.openfile(filename)
            pass
        else:
            master.wm_title("yaesu edit")
            self.fd = None
        pass

    def openfile(self, filename):
        try:
            self.fd = RadioFileData(filename)
            self.radioname = find_radio(self.fd.data)
            self.radio = RadioConfig(radiodir + "/" + self.radioname + ".rad",
                                     self.fd)
        except Exception, e:
            exceptionType, exceptionValue, exceptionTraceback = sys.exc_info()
            traceback.print_exception(exceptionType, exceptionValue,
                                      exceptionTraceback,
                                      file=sys.stdout)
            print str(e)
            return
        self.master.wm_title(filename + " (" + self.radioname + ")")
        self.radio.setup(self)
        pass
    
    def quitcmd(self, event=None):
        if (not self.fd or not self.fd.changed):
            self.quit()
            return
        IsOk("Unchanged data has not been written, do you"
             + " really want to quit?", self.quitok)
        pass

    def quitok(self, val):
        if (val):
            self.quit();
            pass
        return

    def opencmd(self, event=None):
        self.filedialog.popup()
        pass

    def open_select(self, filename):
        if (not filename):
            return
        if (not self.fd):
            self.openfile(filename)
        else:
            root = Tix.Tk()
            GUI(filename, root)
            pass
        return
    
    def saveascmd(self, event=None):
        if (not self.fd):
            return
        self.saveasdialog.popup()
        pass

    def saveas_select(self, filename):
        if (not filename):
            return
        self.fd.write(filename)
        return
    
    def savecmd(self, event=None):
        self.fd.write()
        pass

    def newradio(self, r):
        filename = radiodir + "/" + r.name + ".empty"
        self.open_select(filename)
        pass

    def createWidgets(self):
        self.buttons = Tix.Frame(self)
        self.buttons.pack(side=Tix.TOP, fill=Tix.X)
        
        self.filebutton = Tix.Menubutton(self.buttons, text="File",
                                         underline=0, takefocus=0)
        self.filemenu = Tix.Menu(self.filebutton, tearoff=0)
        self.filebutton["menu"] = self.filemenu
        m = Tix.Menu(self.filemenu)
        for r in radios:
            ns = RadioSel(self, r)
            m.add_command(label=r.name,
                          command = lambda ns=ns: ns.selected())
            pass
        self.filemenu.add_cascade(label="New", underline=1, menu=m)
        self.filemenu.add_command(label="Open", underline=1,
                                  accelerator="Ctrl+O",
                                  command = lambda self=self: self.opencmd() )
        self.filemenu.add_command(label="Save", underline=1,
                                  accelerator="Ctrl+S",
                                  command = lambda self=self: self.savecmd() )
        self.filemenu.add_command(label="Save As", underline=1,
                                  command = lambda self=self: self.saveascmd())
        self.filemenu.add_command(label="Exit", underline=1,
                                  accelerator="Ctrl+Q",
                                  command = lambda self=self: self.quitcmd() )
        self.top.bind_all("<Control-Q>", self.quitcmd)
        self.top.bind_all("<Control-q>", self.quitcmd)
        self.top.bind_all("<Control-S>", self.savecmd)
        self.top.bind_all("<Control-s>", self.savecmd)
        self.filebutton.pack(side=Tix.LEFT)

#         self.editbutton = Tix.Menubutton(self.buttons, text="Edit",
#                                          underline=0, takefocus=0)
#         self.editmenu = Tix.Menu(self.editbutton, tearoff=0)
#         self.editbutton["menu"] = self.editmenu
#         self.editmenu.add_command(label="Preferences", underline=1,
#                                   command = lambda self=self: self.opencmd() )
#         self.editbutton.pack(side=Tix.LEFT)

        pass

progname = sys.argv[0]

while len(sys.argv) > 1:
    if (sys.argv[1][0] != '-'):
        break
    if (sys.argv[1] == '--'):
        del sys.argv[0]
        break
    if (sys.argv[1] == '--configdir' or sys.argv[1] == '-f'):
        if (len(sys.argv[1]) < 2):
            print "No configuration directory given with " + sys.argv[1]
            sys.exit(1)
            pass
        del sys.argv[1]
        radiodir = sys.argv[1]
        del sys.argv[1]
    else:
        print "Unknown option: " + sys.argv[1]
        sys.exit(1)
        pass
    pass

if (len(sys.argv) > 1):
    filename = sys.argv[1]
else:
    filename = None
    pass

read_radios()

root = Tix.Tk();
gui = GUI(filename, root);
gui.mainloop();
sys.exit(0)
